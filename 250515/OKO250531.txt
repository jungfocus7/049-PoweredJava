01) 가장심플 
(SELECT\b\s+?)[\s\S]+?(FROM\b\s+?)[\s\S]+?;\s*?$


02) 살짝 디테일
(SELECT\b\s+?)[\s\S]+?(FROM\b\s+?)[\s\S]+?;\s*?(--.*?)*?$


03) 많이 디테일 (유력)
^[\t ]*?(SELECT\b\s+?)[\s\S]+?(FROM\b\s+?)[\s\S]+?;\s*?(--.*?)*?$





----------------------------------------------------------------------------------------------------
////^[\t [^\(]]*?(SELECT\b\s+?)[\s\S]+?(FROM\b\s+?)[\s\S]+?;\s*?(--.*?)*?$

////(SELECT\b\s+?)[\s\S]+?(FROM\b\s+?)[^;]+?;














기본 콘텐츠로 건너뛰기
스택 오버플로
약
제품
오버플로우AI
검색...
2025년 연례 개발자 설문조사가 진행 중이니 지금 바로 설문조사에 참여하세요!
집
질문
태그
도전










-- SELECT
    eq.equipment_id AS 장비_ID,
    eq.equipment_name AS 장비_이름,
    eq.location AS 장비_위치,
    ps.step_id AS 공정_단계_ID,
    ps.step_name AS 공정_단계_이름,
    TO_CHAR(MIN(ps.start_time), 'YYYY-MM-DD HH24:MI:SS') AS 해당_공정_최소_시작_시간,
    TO_CHAR(MAX(ps.end_time), 'YYYY-MM-DD HH24:MI:SS') AS 해당_공정_최대_종료_시간,
    AVG(TRUNC((ps.end_time - ps.start_time) * 24 * 60 * 60)) AS 평균_공정_소요_시간_초, -- Average process duration in seconds
    COUNT(DISTINCT w.wafer_id) AS 처리된_웨이퍼_수,
    COUNT(d.defect_id) AS 총_발생_불량_수,
    CAST(COUNT(d.defect_id) AS NUMBER) / COUNT(DISTINCT w.wafer_id) AS 웨이퍼당_평균_불량_수,
    MAX(CASE WHEN d.severity = 'CRITICAL' THEN 1 ELSE 0 END) AS 치명적_불량_발생_여부, -- 1 if critical defect occurred, 0 otherwise
    (
        SELECT
            CAST(SUM(CASE WHEN ps_sub.status = 'FAILED' THEN 1 ELSE 0 END) AS NUMBER) / COUNT(ps_sub.step_execution_id) * 100
        FROM
            process_steps ps_sub
        WHERE
            ps_sub.equipment_id = eq.equipment_id
            AND ps_sub.step_id = ps.step_id
            AND ps_sub.start_time BETWEEN TO_DATE('2024-01-01', 'YYYY-MM-DD') AND TO_DATE('2024-12-31', 'YYYY-MM-DD')
    ) AS 해당_장비_공정_실패율_퍼센트,
    SUM(TRUNC((ps.end_time - ps.start_time) * 24)) OVER (PARTITION BY eq.equipment_id) AS 장비별_총_가동_시간_시, -- Total operation hours per equipment
    RANK() OVER (PARTITION BY ps.step_id ORDER BY AVG(TRUNC((ps.end_time - ps.start_time) * 24 * 60 * 60)) ASC) AS 공정별_장비_속도_순위,
    NTILE(4) OVER (PARTITION BY eq.location ORDER BY COUNT(d.defect_id) DESC) AS 위치별_불량_발생_분위, -- Divide into 4 quartiles based on defect count
    LAG(AVG(TRUNC((ps.end_time - ps.start_time) * 24 * 60 * 60)), 1, 0) OVER (PARTITION BY eq.equipment_id ORDER BY ps.step_id) AS 이전_공정_평균_소요_시간_초,
    (
        SELECT
            CAST(COUNT(DISTINCT w_yield.wafer_id) AS NUMBER) / COUNT(DISTINCT l_yield.wafer_id) * 100
        FROM
            wafers w_yield
        JOIN
            lots l_yield ON w_yield.lot_id = l_yield.lot_id
        WHERE
            l_yield.lot_id = l.lot_id
            AND NOT EXISTS (SELECT 1 FROM defects d_yield WHERE d_yield.wafer_id = w_yield.wafer_id)
    ) AS 로트_최종_수율_퍼센트
FROM
    equipment eq
JOIN
    process_steps ps ON eq.equipment_id = ps.equipment_id
JOIN
    wafers w ON ps.wafer_id = w.wafer_id
LEFT JOIN
    defects d ON ps.wafer_id = d.wafer_id AND ps.step_id = d.step_id
JOIN
    lots l ON w.lot_id = l.lot_id -- Join to lots to get lot_id for yield calculation
WHERE
    ps.start_time BETWEEN TO_DATE('2024-01-01', 'YYYY-MM-DD') AND TO_DATE('2024-03-31', 'YYYY-MM-DD') -- Q1 2024 데이터
    AND ps.status IN ('COMPLETED', 'FAILED') -- 완료 또는 실패한 공정 단계만 포함
    AND eq.equipment_type = 'ETCHING_TOOL' -- 특정 장비 유형 필터링
    AND EXISTS (
        SELECT 1
        FROM operators op_sub
        WHERE op_sub.operator_id = ps.operator_id
          AND op_sub.shift = 'NIGHT' -- 야간조 작업자가 처리한 공정만
    )
GROUP BY
    eq.equipment_id, eq.equipment_name, eq.location,
    ps.step_id, ps.step_name, l.lot_id
HAVING
    COUNT(DISTINCT w.wafer_id) > 50 -- 50개 이상의 웨이퍼를 처리한 공정 단계만
ORDER BY
    eq.equipment_name ASC,
    ps.step_id ASC,
    총_발생_불량_수 DESC;    -- dasdaa

-- 가상의 테이블 구조 (참고용)
-- CREATE TABLE lots (
--     lot_id VARCHAR2(50) PRIMARY KEY,
--     batch_id VARCHAR2(50),
--     creation_date DATE,
--     product_type VARCHAR2(50),
--     target_yield NUMBER(5,2)
-- );

-- CREATE TABLE wafers (
--     wafer_id VARCHAR2(50) PRIMARY KEY,
--     lot_id VARCHAR2(50) REFERENCES lots(lot_id),
--     product_type VARCHAR2(50), -- e.g., 'CPU_CHIP', 'MEMORY_CHIP'
--     start_date DATE
-- );

-- CREATE TABLE process_steps (
--     step_execution_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
--     wafer_id VARCHAR2(50) REFERENCES wafers(wafer_id),
--     step_id NUMBER, -- e.g., 10, 20, 30 for different process types
--     step_name VARCHAR2(100), -- e.g., 'Lithography', 'Etching', 'Deposition'
--     equipment_id VARCHAR2(50) REFERENCES equipment(equipment_id),
--     operator_id VARCHAR2(50) REFERENCES operators(operator_id),
--     start_time DATE,
--     end_time DATE,
--     status VARCHAR2(50) -- 'COMPLETED', 'IN_PROGRESS', 'FAILED'
-- );

-- CREATE TABLE equipment (
--     equipment_id VARCHAR2(50) PRIMARY KEY,
--     equipment_name VARCHAR2(100),
--     model VARCHAR2(100),
--     location VARCHAR2(100), -- e.g., 'Fab1-LineA', 'Fab2-LineB'
--     equipment_type VARCHAR2(50) -- e.g., 'LITHOGRAPHY_TOOL', 'ETCHING_TOOL'
-- );

-- CREATE TABLE operators (
--     operator_id VARCHAR2(50) PRIMARY KEY,
--     operator_name VARCHAR2(100),
--     shift VARCHAR2(20) -- 'DAY', 'NIGHT'
-- );

-- CREATE TABLE defects (
--     defect_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
--     wafer_id VARCHAR2(50) REFERENCES wafers(wafer_id),
--     step_id NUMBER, -- Corresponds to process_steps.step_id where defect occurred
--     defect_type VARCHAR2(100), -- e.g., 'Particle', 'Scratch', 'Misalignment'
--     severity VARCHAR2(50), -- 'CRITICAL', 'MAJOR', 'MINOR'
--     occurrence_time DATE
-- );












새로운
잡담
기사
사용자
회사
집단
좋아하는 기술에 대한 커뮤니티. 모든 콜렉티브를 살펴보세요

팀

Stack Overflow for Teams를 사용하여 직장에서 질문하고, 답변을 찾고, 협업하세요.

 




SQL 쿼리 문자열에 SELECT 및 LIMIT가 포함되어 있는지 확인하는 Java Regex
7년 10개월 전에 질문했습니다
수정일: 7년, 10개월 전
조회 3k 회

이 광고 신고하기
1

문자열 형식의 SQL 쿼리가 SELECT로 시작하고 LIMIT와 숫자로 끝나는 경우 유효성을 검사하기 위해 정규식을 작성해야합니다. 물론, 이것은 대소문자를 구분하지 않아야 하며 앞과 뒤에 오는 공백을 무시할 수 있어야 합니다.

Valid String:
1. select * from table where col='anything' limit 10
2. SELECT * from table where col='anything' LIMIT 10

Invalid String:
1. select * from table where col='anything'
2. SELECT * from table where col='anything'
나는 다음을 시도했지만 어떤 경우에도 일치하지 않고 네 가지 경우 모두에 대해 false를 인쇄합니다.

public class Main {

    private static final String  regex   = "^SELECT(?:[^;']|(?:'[^']+'))+ LIMIT + \\d+;\\s*$";
    private static final Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE | Pattern.CASE_INSENSITIVE);

    private static boolean matchesPattern(String query) {
        return pattern.matcher(query).matches();
    }

    public static void main(String[] args) {

        String[] queries = {
                "select * from table where col='anything'",             // should print false, as no limit condition
                "select * from table where col='anything' limit 10",    // should print true
                "SELECT * from table where col='anything'",             // should print false, as no limit condition
                "SELECT * from table where col='anything' LIMIT 10"     // should print true
        };

        for (String query: queries){
            System.out.println(matchesPattern(query));
        }
    }
}

       SELECT *, 'dasd;' FROM 'dasd;dd' USER_INFO WHERE NAME = '박종명'

      

;   





자바정규식
공유
이 질문을 개선하십시오.
뒤따르다
질문함 Jul 21, 2017 에 9:31
OneMoreError의 사용자 아바타
원모어에러
7,73820골드 배지 20개7878 실버 배지115115 청동 배지
1
나는 정규식에서 전문가는 아니지만 LIMIT 전후에 +를 제거해야한다고 생각합니다. 그들은 '한 번 또는 그 이상'을 의미합니다. 
– 
크리스천
 댓글을 달았습니다2017년 7월 21일 9:35
1
'...' 에서 탈출할 수 없습니다. 문자열? BTW, 당신은 단지 ; optional 만들고 \\d+ 앞의 공백을 제거해야합니다 : ^SELECT(?:[^;']|(?:'[^']+'))+ 제한 +\d+;? \s*$입니다. 
– 
빅토르 스트리비제프
 댓글을 달았습니다2017년 7월 21일 9:35 
댓글 추가
2 답변
정렬 기준:

최고 점수(기본값)
2

SELECT
    c.customer_id AS 고객_ID,
    c.customer_name AS 고객_이름,
    c.customer_email AS 고객_이메일,
    o.order_id AS 주문_ID,
    TO_CHAR(o.order_date, 'YYYY-MM-DD HH24:MI:SS') AS 주문_일시,
    o.order_status AS 주문_상태,
    p.product_id AS 상품_ID,
    p.product_name AS 상품_이름,
    cat.category_name AS 상품_카테고리,
    oi.quantity AS 주문_수량,
    oi.unit_price AS 단가,
    (oi.quantity * oi.unit_price) AS 상품별_총_금액,
    NVL(oi.discount_amount, 0) AS 할인_금액,
    (oi.quantity * oi.unit_price - NVL(oi.discount_amount, 0)) AS 실제_결제_금액,
    e.employee_name AS 처리_직원_이름,
    e.employee_department AS 처리_직원_부서,
    CASE
        WHEN o.total_amount >= 100000 THEN '고액_주문'
        WHEN o.total_amount >= 50000 THEN '중액_주문'
        ELSE '소액_주문'
    END AS 주문_금액_구분,
    (SELECT COUNT(oi2.order_item_id) FROM order_items oi2 WHERE oi2.order_id = o.order_id) AS 주문_내_상품_종류_수,
    SUM(oi.quantity * oi.unit_price) OVER (PARTITION BY c.customer_id) AS 고객별_총_구매_금액,
    AVG(oi.quantity * oi.unit_price) OVER (PARTITION BY cat.category_name) AS 카테고리별_평균_상품_금액
FROM
    customers c
JOIN
    orders o ON c.customer_id = o.customer_id
JOIN
    order_items oi ON o.order_id = oi.order_id
JOIN
    products p ON oi.product_id = p.product_id
JOIN
    categories cat ON p.category_id = cat.category_id
LEFT JOIN -- 직원이 없을 수도 있으므로 LEFT JOIN 사용
    employees e ON o.processed_by_employee_id = e.employee_id
WHERE
    o.order_date BETWEEN TO_DATE('2024-01-01', 'YYYY-MM-DD') AND TO_DATE('2024-12-31', 'YYYY-MM-DD')
    AND o.order_status IN ('COMPLETED', 'SHIPPED')
    AND c.customer_type = 'VI;;P' -- 특정 고객 유형 필터링
    AND p.product_status = 'ACTIVE'
    AND EXISTS (
        SELECT 1
        FROM order_items oi_sub
        WHERE oi_sub.order_id = o.order_id
          AND oi_sub.quantity > 2 -- 주문 내에 2개 이상 구매한 상품이 있는 주문만
    )
GROUP BY
    c.customer_id, c.customer_name, c.customer_email,
    o.order_id, o.order_date, o.order_status, o.total_amount,
    p.product_id, p.product_name, cat.category_name,
    oi.quantity, oi.unit_price, oi.discount_amount,
    e.employee_name, e.employee_department
HAVING
    SUM(oi.quantity * oi.unit_price) > 5000 -- 각 주문 항목 그룹의 총 금액이 5000을 초과하는 경우만
ORDER BY
    c.customer_name ASC,
    o.order_date DESC,
    상품별_총_금액 DESC;-- dasd23123 ;  ;      -- dasdqwe
	 
	 

정규식이 올바르지 않습니다.
귀하의 문제에는 다음과 같은 것이 적합합니다.

"^(SELECT|select).*(LIMIT|limit) (\\d+);$"
테스트에서는 쿼리 끝에 a 가 없으므로 절대 true를 반환하지 않는다는 점을 명심하십시오.;

공유
이 답변을 개선하십시오.
뒤따르다
답변됨 2017년 7월 21일 9:39
Christian의 사용자 아바타
크리스천
22.4케이12골드 배지 12개83실버 배지 83개107107 브론즈 배지
댓글 추가
1

현재 패턴에 대한 수정 사항은 앞의 공백을 제거하고 그 뒤에 수량자를 추가하여 선택 사항으로 만드는 것입니다. 쓰다\\d+;?

String regex = "^SELECT(?:[^;']|(?:'[^']+'))+ LIMIT +\\d+;?\\s*$";
정규식 데모를 참조하십시오.

부분에서 2 개 이상의 공백과 일치하고 공백이 1 개 만 있으면 정규식이 아무 것도 일치하지 않습니다.LIMIT + \\d+LIMIT

따라서 올바른 샘플로 끝나지 않으므로 제거하거나 선택 사항으로 만들지 않습니다.;

이스케이프 작은따옴표가 포함될 수 있으므로 패턴을 조정해야 합니다. 작은따옴표로 이스케이프된 경우 패턴 대신 사용하십시오.'...''[^']*(?:''[^']*)*''[^']+'

공유
이 답변을 개선하십시오.
뒤따르다
편집됨 2017년 7월 21일 21:25
답변됨 2017년 7월 21일 9:39
Wiktor Stribiżew의 사용자 아바타
빅토르 스트리비제프
629케이41골드 배지 41개498실버 배지 498개623623 브론즈 배지
답변에 패턴을 추가했습니다. 
– 
빅토르 스트리비제프
 댓글을 달았습니다2017년 7월 21일 21:25 
댓글 추가
당신의 대답
 

  
Sign up or log in
Post as a guest
Name
Email
Required, but never shown

By clicking “Post Your Answer”, you agree to our terms of service and acknowledge you have read our privacy policy.

Start asking to get answers

Find the answer to your question by asking.

Explore related questions

javaregex
See similar questions with these tags.

오버플로 블로그
Salesforce를 위한 에이전트 프레임워크 구축에 대한 심층 분석
단순한 분위기가 아니라 Stack Overflow 개발자 설문 조사가 실제로 여기에 있습니다
다가오는 이벤트
2025년 커뮤니티 중재자 선거
6월 11일까지
Meta에 소개됨
신규 사용자를 대상으로 하는 두 개의 새로운 채팅방 실험
어떻게 하면 스택 생태계에 더 많은 재미를 줄 수 있을까요? 커뮤니티 아이디어를 환영합니다!
스타일/레이아웃 변경 사항을 주석으로 되돌리려면 어떻게 해야 합니까?
댓글 작성 평판 요구 사항 실험
질문자를 커뮤니티의 전문가와 짝지어주는 실험

이 광고 신고하기

이 광고 신고하기
관련
0
Java의 정규식 문자열
1
포함하는 문자열을 선택하십시오.
6
SQL 쿼리를 추출하는 정규식
0
SQL 문자열 감지
1
Java 정규식으로 간단한 SQL 유효성 검사
0
Java를 사용하는 SQL의 정규식
0
Java Regex : SQL 쿼리에서 반환 할 행 수를 알고 싶습니다.
0
SQL의 유효성을 검사하기 위한 정규식
0
정규식 - SQL 문
3
Java - SQL 쿼리에 대한 정규식
핫 네트워크 질문
이항 계수의 아래 첨자에 대한 간격 조정
성공적인 평가에 대한 답변
'나무 그루터기'가 여기서 사용하는 올바른 단어입니까?
학자들은 커티스 야빈과 신반동 운동을 깎아내리기 위해 어떤 증거를 제시할 것인가?
당좌 예금 계좌 잔액으로 자기앞 수표를 구입할 수 있습니까?
말과 수레에 놀란 아프리카 마을 사람에 대한 접선 통로가 있는 이야기
항아리에서 무작위 공을 제거한 후에도 녹색 공을 뽑을 확률이 변경되지 않는 이유는 무엇입니까?
아파치 디렉토리 구성을 sed로 바꾸는 방법은 무엇입니까?
ImageIO를 사용하여 크기를 조정하고, PNG 투명도를 평면화하고, Base64 이미지를 JPEG로 압축하는 Java 방법
나는 어떤 우주에 갇혀 있는 걸까?
중고 골드 인증으로 광고된 신차... 사기?
LaTeX 문장 텍스트 개체
팀 선택기 명령줄 응용 프로그램
주님께서는 왜 알파벳을 언급하시는가?
유리에서 다른 빛의 주파수의 속도가 다른 경우; 빛의 주파수가 Maxwell 방정식의 표현에 의해 생성되는 속도는 다음과 같습니다.
Make coauthors let go of paper
"11" overlapping sequence detector using mealy machine
Letter u in Classical Latin
From simple melodies to small tracks
Co2 Sensors Warning or Internet Connection
Find the Coastline #2
Can I request acceptance decision from journal based on only one reviewer's recommendation?
Mesh not moving with armature in some places
Does Sharpshooter work with thrown weapons like daggers?
 Question feed





Stack Overflow
Questions
Help
Chat
Products
Teams
Advertising
Talent
Company
About
Press
Work Here
Legal
Privacy Policy
Terms of Service
Contact Us
Cookie Settings
Cookie Policy
Stack Exchange Network
Technology
Culture & recreation
Life & arts
Science
Professional
Business
API


---------------------------------------
SELECT
    e.employee_id AS 직원_ID,
    e.first_name || ' ' || e.last_name AS 직원_이름,
    d.department_name AS 부서_이름,
    j.job_title AS 직무,
    TO_CHAR(e.hire_date, 'YYYY-MM-DD') AS 입사일,
    TRUNC(MONTHS_BETWEEN(SYSDATE, e.hire_date) / 12) AS 근속_년수,
    s.salary AS 현재_급여,
    s.effective_date AS 현재_급여_적용일,
    (SELECT COUNT(ep.project_id) FROM employee_projects ep WHERE ep.employee_id = e.employee_id) AS 참여_프로젝트_수,
    NVL(MAX(CASE WHEN p.project_status = 'COMPLETED' THEN p.project_name END), '없음') AS 최근_완료_프로젝트,
    NVL(MAX(CASE WHEN p.project_status = 'IN_PROGRESS' THEN p.project_name END), '없음') AS 현재_진행_프로젝트,
    CASE
        WHEN s.salary >= 100000 THEN '고액_연봉자'
        WHEN s.salary >= 60000 THEN '중액_연봉자'
        ELSE '일반_연봉자'
    END AS 연봉_구분,
    LAG(s.salary, 1, 0) OVER (PARTITION BY e.employee_id ORDER BY s.effective_date) AS 이전_급여,
    s.salary - LAG(s.salary, 1, 0) OVER (PARTITION BY e.employee_id ORDER BY s.effective_date) AS 급여_변동액,
    ROW_NUMBER() OVER (PARTITION BY d.department_id ORDER BY s.salary DESC) AS 부서내_급여_순위,
    RANK() OVER (ORDER BY s.salary DESC) AS 전체_급여_랭크,
    (
        SELECT AVG(s_sub.salary)
        FROM salaries s_sub
        JOIN employees e_sub ON s_sub.employee_id = e_sub.employee_id
        WHERE e_sub.performance_rating = e.performance_rating
          AND s_sub.effective_date = (SELECT MAX(effective_date) FROM salaries WHERE employee_id = e_sub.employee_id)
    ) AS 동일_성과_등급_평균_급여,
    (
        SELECT SUM(budget)
        FROM projects pr
        JOIN employee_projects ep_sub ON pr.project_id = ep_sub.project_id
        WHERE ep_sub.employee_id = e.employee_id
    ) AS 참여_프로젝트_총_예산,
    AVG(s.salary) OVER (PARTITION BY d.department_name) AS 부서별_평균_급여,
    COUNT(e.employee_id) OVER (PARTITION BY j.job_title) AS 직무별_직원수
FROM
    employees e
JOIN
    departments d ON e.department_id = d.department_id
JOIN
    jobs j ON e.job_id = j.job_id
LEFT JOIN -- 최신 급여 정보를 가져오기 위한 조인
    salaries s ON e.employee_id = s.employee_id
WHERE
    s.effective_date = (SELECT MAX(effective_date) FROM salaries WHERE employee_id = e.employee_id) -- 최신 급여만 선택
    AND d.department_name IN ('Sales', 'Marketing', 'IT') -- 특정 부서 필터링
    AND e.hire_date >= TO_DATE('2020-01-01', 'YYYY-MM-DD') -- 2020년 이후 입사자
    AND EXISTS (
        SELECT 1
        FROM employee_projects ep_sub
        WHERE ep_sub.employee_id = e.employee_id
          AND ep_sub.start_date >= ADD_MONTHS(SYSDATE, -6) -- 최근 6개월 이내 프로젝트 참여 이력
    )
GROUP BY
    e.employee_id, e.first_name, e.last_name, d.department_name, j.job_title,
    e.hire_date, s.salary, s.effective_date, e.performance_rating
HAVING
    COUNT(DISTINCT ep.project_id) >= 1 -- 최소 1개 이상의 프로젝트에 참여한 직원만
ORDER BY
    d.department_name ASC,
    s.salary DESC;      -- 기술려 과정 처라ㅣ
---------------------------------------





Data
Blog
Facebook
Twitter
LinkedIn
Instagram
Site design / logo © 2025 Stack Exchange Inc; user contributions licensed under CC BY-SA . rev 2025.5.30.27971